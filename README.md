# pract-3.1-3.5
# Сортировка выбором (Selection Sort)
* Определение: Алгоритм сортировки, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.
* Принцип работы алгоритма:
Алгоритм мысленно делит массив на две части: отсортированную (в начале) и неотсортированную. На каждом шаге он сканирует неотсортированную часть, находит минимальный элемент и меняет его местами с первым элементом неотсортированной части. Таким образом, отсортированная часть увеличивается на один элемент, а неотсортированная — уменьшается.
* O(n²). Объяснение O(n²):
Для нахождения минимального элемента в неотсортированной части (размером k) требуется k сравнений.

Первый проход: n сравнений
Второй проход: n-1 сравнений
...
Последний проход: 1 сравнение
n + (n-1) + ... + 1 = n(n+1)/2 ≈ n²
Таким образом, количество операций растет квадратично от размера массива.

# Сортировка пузырьком (Bubble Sort)
* Определение: Алгоритм сортировки, который многократно проходит по массиву, сравнивая и меняя местами соседние элементы, если они находятся в неправильном порядке, пока массив не будет полностью отсортирован.
* Принцип работы алгоритма:
Алгоритм многократно проходит по массиву, сравнивая соседние элементы. Если они расположены в неправильном порядке (больший элемент стоит перед меньшим), алгоритм меняет их местами. В результате каждого такого прохода самый большой элемент из неотсортированной части "всплывает" к своему правильному месту в конце массива, как пузырек.
* O(n²). Объяснение O(n²):
В худшем случае (массив отсортирован в обратном порядке) требуется n-1 проходов, и на каждом проходе выполняется n-1 сравнений.
(n-1) × (n-1) ≈ n²
Даже с оптимизацией (остановка, если не было обменов), в худшем случае сложность остается квадратичной.

# Сортировка вставками (Insertion Sort)
* Определение: Алгоритм сортировки, который строит отсортированную последовательность, поочередно вставляя каждый следующий элемент в правильную позицию внутри уже отсортированной части массива.
* Принцип работы алгоритма:
Алгоритм обрабатывает элементы массива по одному, начиная со второго. Каждый новый элемент "вставляется" в уже отсортированную часть массива (слева). Для этого алгоритм находит правильную позицию для элемента в отсортированной части, сдвигая все большие элементы вправо, чтобы освободить место.
* O(n²). Объяснение O(n²):
В худшем случае (массив отсортирован в обратном порядке) для вставки каждого нового элемента требуется:

Сравнить его со всеми элементами в отсортированной части
Сдвинуть все элементы отсортированной части
Для k-го элемента требуется до k операций:
1 + 2 + 3 + ... + (n-1) = n(n-1)/2 ≈ n²

# Сортировка слиянием (Merge Sort)
* Определение: Алгоритм сортировки, основанный на принципе "разделяй и властвуй", который рекурсивно делит массив пополам, сортирует каждую половину, а затем сливает отсортированные половины в один массив.
* Принцип работы алгоритма:
Алгоритм использует стратегию "разделяй и властвуй":
Разделение: массив рекурсивно делится пополам, пока не останутся подмассивы из одного элемента (которые уже отсортированы).
Слияние: два отсортированных подмассива сливаются в один отсортированный массив путем последовательного сравнения их элементов и выбора минимального.
* O(n log n). Объяснение O(n log n):

Глубина рекурсии: массив делится пополам log₂n раз
На каждом уровне рекурсии выполняется слияние всех элементов (операций O(n))
Уровни × Операции на уровне = log n × n = O(n log n)

# Сортировка Шелла (Shell Sort)
* Определение: Усовершенствованный вариант сортировки вставками, который сортирует элементы, расположенные на определенном расстоянии друг от друга, постепенно уменьшая это расстояние до единицы.
* Принцип работы алгоритма:
Это улучшенная версия сортировки вставками. Алгоритм сортирует элементы, стоящие на определенном расстоянии (шаге) друг от друга. Шаг постепенно уменьшается до 1. На последнем шаге (шаг = 1) выполняется обычная сортировка вставками, но к этому моменту массив уже "почти отсортирован".
* O(n²). Объяснение O(n²):
В худшем случае (неудачная последовательность шагов) сложность остается квадратичной. Однако на практике при хорошем выборе последовательности шагов сложность может быть O(n^(3/2)) или даже O(n log²n).

# Быстрая сортировка (Quick Sort)
*Определение: Эффективный алгоритм сортировки, который выбирает опорный элемент и перераспределяет остальные элементы так, чтобы меньшие элементы оказались слева, а большие - справа от опора, затем рекурсивно применяет этот же процесс к обеим частям.
* Принцип работы алгоритма:
Алгоритм также использует "разделяй и властвуй":
Выбор опорного элемента (pivot)
Разделение: перераспределение элементов так, чтобы все элементы меньше опорного оказались слева, а больше — справа
Рекурсивная сортировка левой и правой частей
* O(n log n) / O(n²). Объяснение O(n log n) / O(n²):

В среднем: при случайном выборе опорного элемента массив делится примерно пополам → глубина рекурсии log n, на каждом уровне O(n) операций → O(n log n)
В худшем случае: если опорный элемент всегда минимальный или максимальный (массив уже отсортирован), глубина рекурсии n → O(n²)

# Пирамидальная сортировка (Heap Sort)
* Определение: Алгоритм сортировки, который использует структуру данных "двоичная куча" для организации элементов, последовательно извлекая максимальный элемент из кучи и помещая его в конец массива.
* Принцип работы алгоритма:
Алгоритм использует структуру данных "двоичная куча" (heap):
Построение max-кучи из массива (наибольший элемент — в корне)
Извлечение максимума: корень кучи (максимальный элемент) перемещается в конец массива
Восстановление свойства кучи для оставшихся элементов
Повторение шагов 2-3 пока куча не опустеет
* O(n log n). Объяснение O(n log n):

Построение кучи: O(n)
Каждое из n извлечений максимума требует восстановления кучи: O(log n)
Итого: O(n) + O(n log n) = O(n log n)

# Линейный поиск (Linear Search)
* Определение: Простейший алгоритм поиска, который последовательно проверяет каждый элемент коллекции до тех пор, пока не найдет искомый элемент или не достигнет конца коллекции.
* Принцип работы алгоритма:
Алгоритм последовательно проверяет каждый элемент массива от начала до конца, сравнивая его с искомым значением. Поиск прекращается при нахождении совпадения или достижении конца массива.
* O(n). Объяснение O(n):
В худшем случае (элемент отсутствует или находится в конце) требуется проверить все n элементов. Количество операций линейно зависит от размера массива.

# Бинарный поиск (Binary Search)
* Определение: Эффективный алгоритм поиска в отсортированном массиве, который на каждом шаге сравнивает искомый элемент со средним элементом текущего диапазона и продолжает поиск в левой или правой половине в зависимости от результата сравнения.
* Принцип работы алгоритма:
Алгоритм работает только на отсортированном массиве. На каждом шаге он:
Сравнивает искомый элемент с серединным элементом массива
Если элементы равны — поиск завершен
Если искомый элемент меньше — поиск продолжается в левой половине
Если искомый элемент больше — поиск продолжается в правой половине
* O(log n). Объяснение O(log n):
На каждом шаге область поиска уменьшается вдвое. Максимальное количество шагов: log₂n (сколько раз можно разделить n элементов пополам, пока не останется один).

# Интерполяционный поиск (Interpolation Search)
* Определение: Улучшенный алгоритм поиска в отсортированном массиве с равномерно распределенными значениями, который предсказывает позицию искомого элемента на основе его значения и значений на границах текущего диапазона.
* Принцип работы алгоритма:
Улучшенная версия бинарного поиска для равномерно распределенных данных. Вместо деления области поиска пополам, алгоритм предсказывает позицию искомого элемента на основе его значения и значений на границах области поиска (по формуле линейной интерполяции).
* O(log log n) / O(n). Объяснение O(log log n) / O(n):

В лучшем случае (равномерное распределение): количество шагов O(log log n) — очень быстро
В худшем случае (сильно неравномерное распределение): вырождается в линейный поиск → O(n)

# Поиск Фибоначчи (Fibonacci Search)
* Определение: Алгоритм поиска в отсортированном массиве, который использует числа Фибоначчи для определения позиций сравнения, что позволяет избежать операции деления и уменьшить количество сравнений.
* Принцип работы алгоритма:
Алгоритм использует числа Фибоначчи для определения позиций сравнения. Он делит массив на части, пропорциональные соседним числам Фибоначчи. Это позволяет избежать деления (более эффективно на некоторых архитектурах) и уменьшить количество сравнений.
* O(log n). Объяснение O(log n):
Как и бинарный поиск, алгоритм на каждом шаге уменьшает область поиска, но использует другое соотношение (золотое сечение). Глубина рекурсии пропорциональна log n.

